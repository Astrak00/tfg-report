\chapter{Problem Statement \& Analysis}\label{chap:analysis}

This chapter contains an analysis of the functionalities provided by the ray-tracer and the accompanying helper files. The objective of this analysis is to provide a clear understanding of the requirements and functionalities that the ray-tracer must fulfill, as well as the constraints and non-functional requirements that must be considered during its development.

To achieve this, we will define the user requirements, functional and non-functional requirements, and restrictions the ray-tracer must adhere to. Then, we will present a use case diagram that illustrates the interactions between the user and the ray-tracer, as well as traceability matrices that link the requirements to the use cases and functionalities of the ray-tracer.

\section{Project Description}
This project aims to create a suite of programs that implement a ray-tracer engine in multiple programming languages, including C++, Python, and Go. The goal is to create the pipeline to benchmark the performance and energy efficiency of each implementation, in multiple-core and single-core configurations.

Each implementation has to be able to run on macOS and Linux, and the energy consumption evaluation of each benchmark must work on each platform, as not all platforms support the same energy consumption evaluation tools\footnote{macOS uses \texttt{powermetrics} and Linux uses \texttt{perf} and a Raspberry Pi needs its power measured from the input source, as it does not have any internal counters}. This project is only implemented to run on \glspl{cpu} as this projects' scope does not include \glspl{gpu}.


\section{Requirements}


The requirements for this project are divided into two main categories user requirements and program requirements. All of these requirements have been defined following the IEEE 29148:2018 standard:~\autocite{requirements-engineering-iso}. 

To better organize the requirements, we will use the following abbreviations:

% Abbreviations used in this document:
\begin{description}
    \item[FN]  Functional
    \item[NF]  Non-Functional
\end{description}


To better describe these requirements, we will use the format described in \autoref{tab:req-format-xx}.


\begin{table}[H]
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{RY-XX}} \\
        \toprule
        \textbf{Name}               & Clear and concise title representing the functionality or constraint \\
        \textbf{Type}               & Functional / Non-Functional \\
        \textbf{Necessity}          & Optional / Essential / Desirable \\
        \textbf{Priority}           & Low / Medium / High \\
        \textbf{Complexity}         & Low / Medium / High \\
        \textbf{Description}        & Brief description of the requirement \\
        \bottomrule
    \end{tabular}
\caption{Requirement Template}\label{tab:req-format-xx}
\end{table}

\begin{itemize}
    \item \textbf{Identifier}: code that identifies the requirement, following the schema \textit{RY-XX}, where `Y' is the type of requirement (`F' for Functional, `NF' for Non-Functional) and `XX' is a two-digit number that identifies the requirement.
    \item \textbf{Name}: clear and concise title, representing the functionality or constraint of the requirement.
    \item \textbf{Type}: indicates the type of the requirement, which can be functional or non-functional.
    \item \textbf{Necessity}: 
        \begin{itemize}
            \item \textit{Optional}: the requirement is not essential for the system to function, but it would be nice to have.
            \item \textit{Essential}: the requirement is necessary for the system to function.
            \item \textit{Desirable}: the requirement is not essential, but it would be beneficial for the user.
        \end{itemize}
    \item \textbf{Priority}: indicates the importance or urgency of the requirement, which can be low, medium or high.
    \item \textbf{Complexity}: establishes the level of effort required to implement the requirement, which can be low, medium or high.
    \item \textbf{Description}: a brief description of the requirement.
\end{itemize}


\subsection{Functional requirements}

\input{parts/requirements/functional.tex}

\subsection{Non-Functional requirements}

\input{parts/requirements/non-functional.tex}

\section{Use Case}\label{sec:use-case}

This section describes the use cases of the system. The use cases are represented in a diagram that shows the interactions between the user and the system. The `User' is considered to be a researcher who will use the system to generate images using the ray-tracer engine to analyze the performance and energy efficiency of the different implementations.


\input{parts/diagrams/use-case-diagram.tex}

Use case template:

\begin{table}[H]
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{ID:\@ UC-XX}} \\
        \toprule
        \textbf{Name}               &  The name of the use case inside the diagram. \\
        \textbf{Actors}             &  User, System \\
        \textbf{Objective}          &  Brief description of the goal of the use case. \\
        \textbf{Description}        &  Steps the actor has to perform. \\
        \textbf{Preconditions}      &  The user has the system installed and configured. \\
        \textbf{Postconditions}     &  The benchmarks are executed, and the results are stored. \\
    \end{tabular}
    \caption{Use Case Template}\label{tab:uc-xx}
\end{table}

\begin{itemize}
    \item \textbf{ID}: code that identifies the use case, following the schema \textit{UC-XX}, where `XX' is a two-digit number that identifies the use case.
    \item \textbf{Name}: the name of the use case inside the diagram.
    \item \textbf{Actors}: entities that interact with the system.
    \item \textbf{Objective}: brief description of the goal of the use case.
    \item \textbf{Description}: steps the actor has to perform to achieve the objective of the use case.
    \item \textbf{Preconditions}: conditions that must be met before the use case can be executed.
    \item \textbf{Postconditions}: conditions that must be met after the use case is executed.
\end{itemize}

\begin{table}[H]
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{ID:\@ UC-01}} \\
        \toprule
        \textbf{Name}               &  Generate Image \\
        \textbf{Actors}             &  User \\
        \textbf{Objective}          &  Generate a rendered image using the ray-tracer engine with the selected configuration. \\
        \textbf{Description}        & \textsl{1.} The user downloads the code repository. \\
                                   & \textsl{2.} The user sets the number of cores to use for rendering (CORES=<num>). \\
                                   & \textsl{3.} The user selects the platform (SERVER / macOS / RPI). \\
                                   & \textsl{4.} The user executes the command to generate the image. \\
                                   & \textsl{5.} The program processes the scene and outputs the rendered image file. \\
        \textbf{Preconditions}      &  The code repository has been downloaded. The number of cores and platform have been set. \\
        \textbf{Postconditions}     &  The rendered image is generated and stored in the output directory. \\
    \end{tabular}
    \caption{Use Case UC-01}\label{tab:uc-01}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{ID:\@ UC-02}} \\
        \toprule
        \textbf{Name}               &  Edit Scene file \\
        \textbf{Actors}             &  User \\
        \textbf{Objective}          &  Edit the scene file to change the parameters of the scene to be rendered. \\
        \textbf{Description}        & \textsl{1.} The user opens the scene file in a text editor. \\
                                   & \textsl{2.} The user modifies the parameters of the scene, such as camera position, light sources, and objects. \\
                                   & \textsl{3.} The user saves the changes to the scene file. \\
                                   & \textsl{4.} The user can repeat the process to make further changes to the scene file. \\
        \textbf{Preconditions}      &  The scene file is accessible and editable. \\
        \textbf{Postconditions}     &  The scene file is updated with the new parameters. \\
    \end{tabular}
    \caption{Use Case UC-02}\label{tab:uc-02}
\end{table} 

\begin{table}
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{ID:\@ UC-03}} \\
        \toprule
        \textbf{Name}               &  Set Cores to be used \\
        \textbf{Actors}             &  User \\
        \textbf{Objective}          &  Set the number of cores to be used for rendering the image. \\
        \multirow{1}{*}{\textbf{Description}} & \textsl{1.} The user opens the configuration file.\\
                                             & \textsl{2.} The user sets the number of cores to be used for rendering (CORES=<num>).\\
                                             & \textsl{3.} The user saves the changes to the configuration file.\\
        \textbf{Preconditions}      &  The configuration file is accessible and editable. \\
        \textbf{Postconditions}     &  The configuration file is updated with the new number of cores. \\
    \end{tabular}
    \caption{Use Case UC-03}\label{tab:uc-03}
\end{table}


\begin{table}[H]
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{ID:\@ UC-04}} \\
        \toprule
        \textbf{Name}               &  Select Programming Language \\
        \textbf{Actors}             &  User \\
        \textbf{Objective}          &  Choose the programming language (Python, C++, or Go) for the ray-tracer execution. \\
        \textbf{Description}        & \textsl{1.} The user reviews the available implementations. \\
                                   & \textsl{2.} The user selects the desired programming language (Python, C++, or Go). \\
                                   & \textsl{3.} The user ensures the required dependencies for the selected language are installed. \\
                                   & \textsl{4.} The user proceeds to execute the benchmark or rendering task using the chosen implementation. \\
        \textbf{Preconditions}      &  All language implementations are available and properly installed. \\
        \textbf{Postconditions}     &  The selected language implementation is used for subsequent operations. \\
    \end{tabular}
    \caption{Use Case UC-04}\label{tab:uc-04}
\end{table}


\section{Traceability}

This section provides a traceability matrix that maps the requirements to the use cases. The matrix is designed to ensure that all requirements are addressed by the use cases defined in this document. \autoref{tab:func-traceability-matrix} shows the functional requirements, while \autoref{tab:non-func-traceability-matrix} shows the non-functional requirements, both with their corresponding use cases.



\begin{table}[]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Requirement} & \textbf{UC-01} & \textbf{UC-02} & \textbf{UC-03} & \textbf{UC-04} \\
        \hline
        RF-01                &  \checkmark    &   \checkmark   &  \checkmark    &  \checkmark    \\
        \hline
        RF-02                &  \checkmark    &                &                &                \\
        \hline
        RF-03                &                &                &  \checkmark    &                \\
        \hline
        RF-04                &                &                &  \checkmark    &                \\
        \hline
        RF-05                &  \checkmark    &                &  \checkmark    &                \\
        \hline
        RF-06                &  \checkmark    &                & \checkmark     &                \\
        \hline
        RF-07                &  \checkmark    &  \checkmark    &                &                \\
        \hline
        RF-08                &  \checkmark    &  \checkmark    &                &  \checkmark    \\         
        \hline
        RF-09                &                &                &  \checkmark    &                \\
        \hline
        RF-10                &  \checkmark    &                &                &                \\
        \hline
        RF-11                &  \checkmark    &                &                &                \\
        \hline
        RF-12                &  \checkmark    &  \checkmark    &  \checkmark    &  \checkmark    \\
        \hline  
        RF-13                &  \checkmark    &                &                &                \\
        \hline 
        RF-14                &  \checkmark    &                &                &                \\
        \hline
        RF-15                &  \checkmark    &                &                &                \\
        \hline
        RF-16                &  \checkmark    &                &                &                \\
        \hline
        RF-17                &  \checkmark    &                &                &  \checkmark     \\
        \hline
    \end{tabular}
\caption{Traceability matrix for functional requirement}\label{tab:func-traceability-matrix}
\end{table}



\begin{table}[]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Requirement} & \textbf{UC-01} & \textbf{UC-02} & \textbf{UC-03} & \textbf{UC-04} \\
        \hline
        RNF-01                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-02                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-03                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-04                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-05                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-06                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-07                & \checkmark     & \checkmark     &                &  \checkmark    \\       
        \hline
    \end{tabular}
\caption{Traceability matrix for non-functional requirement}\label{tab:non-func-traceability-matrix}
\end{table}


\input{parts/diagrams/system-architecture.tex}

The system architecture diagram uses the following visual conventions:

\begin{table}[H]
    \centering
    \begin{tabular}{c l}
        \toprule
        \textbf{Symbol} & \textbf{Description} \\
        \midrule
        \tikz[baseline=-0.5ex]\node[block, text width=5em, minimum height=2em] {Component}; & Program components and entry points \\[0.5em]
        \\ 
        \tikz[baseline=-0.5ex]\node[io, text width=4em, minimum height=2em] {File}; & Input/output files and build scripts \\[0.5em]
        \\
        \tikz[baseline=-0.5ex]\node[class, text width=4em, minimum height=2em] {Class}; & Implementation classes \\[0.5em]
        \\
        \tikz[baseline=-0.5ex]\node[baseclass, text width=4em, minimum height=2em] {Base Class}; & Abstract base classes \\[0.5em]
        \\
        \tikz[baseline=-0.5ex]\node[datastruct, text width=4em, minimum height=2em] {Data Type}; & Data structures and types \\[0.5em]
        \\
        \tikz[baseline=-0.5ex]\draw[-latex, thick] (0,0) -- (1,0); & Direct relationship or dependency \\[0.5em]
        \\
        \tikz[baseline=-0.5ex]\draw[dashed, -latex, thick] (0,0) -- (1,0); & Inheritance relationship \\
        \\
        \bottomrule
    \end{tabular}
    \caption{Diagram Key for System Architecture}\label{tab:diagram-key}
\end{table}


The principal components of the system, shown in \autoref{fig:system-architecture}, are:
\begin{itemize}
    \item \textbf{sphere\_data.txt}: the file that contains the scene data, which is read by the program to generate the image. This is where the user can modify the scene parameters, adding more spheres, changing their positions, colors and materials.
    \item \textbf{Makefile}: the file that contains the build instructions for the program, which is used to compile and run the program. It also restricts the number of cores to be used for rendering and organizes the energy consumption and execution time measurements.
    \item \textbf{main}: the entry point of the program, which reads the sphere data, initializes the camera, the world and calls the rendering function.
    \item \textbf{camera}: the class that represents the camera used to render the scene, which is responsible for generating the rays and writing the pixels to the image.
    \item \textbf{hittable\_list}: the class that represents the world (all the elements in the scene), which contains a list of hittable objects (spheres) and is responsible for checking if a ray hits any of the objects in the scene.
    \item \textbf{hittable}: the base class for all hittable objects in the scene, which defines the interface for checking if a ray hits an object.
    \item \textbf{sphere}: the specification of a hittable object of a sphere, which inherits from the hittable class and implements the specific behavior for spheres.
    \item \textbf{material}: the base class for all materials used in the scene, which defines the interface for calculating the color of a ray hit.
    \item \textbf{Image}: the class that represents the image to be generated, which is responsible for storing the pixels and writing the image to a file.
    \item \textbf{output.ppm}: the file that contains the generated image, which is written by the \texttt{Image} class after rendering the scene.
\end{itemize}