\chapter{Problem Statement \& Analysis}\label{chap:analysis}

This chapter contains an analysis of the functionalities provided by the simulator and the accompanying helper files. The objective of this analysis is to provide a clear understanding of the requirements and functionalities that the simulator must fulfill, as well as the constraints and non-functional requirements that must be considered during its development.

To achieve this, we will define the user requirements, functional and non-functional requirements, and restrictions that the simulator must adhere to. Then, we will present a use case diagram that illustrates the interactions between the user and the simulator, as well as traceability matrices that link the requirements to the use cases and functionalities of the simulator.

\section{Project Description}
This project aims to create a suite of programs that implement a ray-tracer engine in multiple programming languages, including C++, Python and Go. The goal is creating the pipeline to benchmark the performance and energy efficiency of each implementation, in multiple-core and single-core configurations.

Each implementation has to be able to run on macOS and Linux, and the energy consumption evaluation of each benchmark must work on each platform, as not all platforms support the same energy consumption evaluation tools.\footnote{macOS uses \texttt{powermetrics} and Linux uses \texttt{perf} and a Raspberry Pi needs its power measured from the input source, as it does not have any internal counters} This project is only implemented to run on \glspl{cpu} as this projects' scope does not include \glspl{gpu}.


\section{Requirements}


The requirements for this project are divided into two main categories user requirements and program requirement. All of these requirements have been defined following the standard~\cite{requirements-engineering-iso}. 

To better organize the requirements, we will use the following abbreviations:

% Abbreviations used in this document:
\begin{description}
    \item[FN]  Functional
    \item[NF]  Non-Functional
\end{description}


To better describe these requirements, we will use the format described in \autoref{tab:req-format-xx}.


\begin{table}[H]
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{RY-XX}} \\
        \toprule
        \textbf{Name}               & Clear and concise title representing the functionality or constraint \\
        \textbf{Type}               & Functional / Non-Functional \\
        \textbf{Necessity}          & Optional / Essential / Desirable \\
        \textbf{Priority}           & Low / Medium / High \\
        \textbf{Complexity}         & Low / Medium / High \\
        \textbf{Description}        & Brief description of the requirement \\
        \bottomrule
    \end{tabular}
\caption{Requirement format template}\label{tab:req-format-xx}
\end{table}

\begin{itemize}
    \item \textbf{Identifier}: code that identifies the requirement, following the schema \textit{RY-XX}, where `Y' is the type of requirement (`F' for Functional, `NF' for Non-Functional) and `XX' is a two-digit number that identifies the requirement.
    \item \textbf{Name}: clear and concise title, representing the functionality or constraint of the requirement.
    \item \textbf{Type}: indicates the type of the requirement, which can be functional or non-functional.
    \item \textbf{Necessity}: 
        \begin{itemize}
            \item \textit{Optional}: the requirement is not essential for the system to function, but it would be nice to have.
            \item \textit{Essential}: the requirement is necessary for the system to function.
            \item \textit{Desirable}: the requirement is not essential, but it would be beneficial for the user.
        \end{itemize}
    \item \textbf{Priority}: indicates the importance or urgency of the requirement, which can be low, medium or high.
    \item \textbf{Complexity}: establishes the level of effort required to implement the requirement, which can be low, medium or high.
    \item \textbf{Description}: a brief description of the requirement.
\end{itemize}


\subsection{Functional requirements}

\input{parts/requirements/functional.tex}

\subsection{Non-Functional requirements}

\input{parts/requirements/non-functional.tex}


\section{Use Case}\label{sec:use-case}

This section describes the use cases of the system. The use cases are represented in a diagram that shows the interactions between the user and the system. The `User' is considered to be a software engineer who will use the system to generate images using the ray-tracer engine to analyze the performance and energy efficiency of the different implementations.


\input{parts/diagrams/use-case-diagram.tex}

Use case template:

\begin{table}[H]
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{ID:\@ UC-XX}} \\
        \toprule
        \textbf{Name}               &  The name of the use case inside the diagram. \\
        \textbf{Actors}             &  User, System \\
        \textbf{Objective}          &  Brief description of the goal of the use case. \\
        \textbf{Description}        &  Steps the actor has to entail. \\
        \textbf{Preconditions}      &  The user has the system installed and configured. \\
        \textbf{Postconditions}     &  The benchmarks are executed, and the results are stored. \\
    \end{tabular}
    \caption{Use Case UC-XX}\label{tab:uc-xx}
\end{table}

\begin{itemize}
    \item \textbf{ID}: code that identifies the use case, following the schema \textit{UC-XX}, where `XX' is a two-digit number that identifies the use case.
    \item \textbf{Name}: the name of the use case inside the diagram.
    \item \textbf{Actors}: entities that interact with the system.
    \item \textbf{Objective}: brief description of the goal of the use case.
    \item \textbf{Description}: steps the actor has to entail to achieve the objective of the use case.
    \item \textbf{Preconditions}: conditions that must be met before the use case can be executed.
    \item \textbf{Postconditions}: conditions that must be met after the use case is executed.
\end{itemize}

\begin{table}[H]
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{ID:\@ UC-01}} \\
        \toprule
        \textbf{Name}               &  Generate Image \\
        \textbf{Actors}             &  User \\
        \textbf{Objective}          &  Generate a rendered image using the ray-tracer engine with the selected configuration. \\
        \textbf{Description}        & \textsl{1.} The user downloads the code repository. \\
                                   & \textsl{2.} The user sets the number of cores to use for rendering (CORES=<num>). \\
                                   & \textsl{3.} The user selects the platform (SERVER / macOS / RPI). \\
                                   & \textsl{4.} The user executes the command to generate the image. \\
                                   & \textsl{5.} The system processes the scene and outputs the rendered image file. \\
        \textbf{Preconditions}      &  The code repository has been downloaded. The number of cores and platform have been set. \\
        \textbf{Postconditions}     &  The rendered image is generated and stored in the output directory. \\
    \end{tabular}
    \caption{Use Case UC-01}\label{tab:uc-01}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{ID:\@ UC-02}} \\
        \toprule
        \textbf{Name}               &  Edit Scene file \\
        \textbf{Actors}             &  User \\
        \textbf{Objective}          &  Edit the scene file to change the parameters of the scene to be rendered. \\
        \textbf{Description}        & \textsl{1.} The user opens the scene file in a text editor. \\
                                   & \textsl{2.} The user modifies the parameters of the scene, such as camera position, light sources, and objects. \\
                                   & \textsl{3.} The user saves the changes to the scene file. \\
                                   & \textsl{4.} The user can repeat the process to make further changes to the scene file. \\
        \textbf{Preconditions}      &  The scene file is accessible and editable. \\
        \textbf{Postconditions}     &  The scene file is updated with the new parameters. \\
    \end{tabular}
    \caption{Use Case UC-02}\label{tab:uc-02}
\end{table} 

\begin{table}
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{ID:\@ UC-03}} \\
        \toprule
        \textbf{Name}               &  Set Cores to be used \\
        \textbf{Actors}             &  User \\
        \textbf{Objective}          &  Set the number of cores to be used for rendering the image. \\
        \multirow{1}{*}{\textbf{Description}} & \textsl{1.} The user opens the configuration file.\\
                                             & \textsl{2.} The user sets the number of cores to be used for rendering (CORES=<num>).\\
                                             & \textsl{3.} The user saves the changes to the configuration file.\\
        \textbf{Preconditions}      &  The configuration file is accessible and editable. \\
        \textbf{Postconditions}     &  The configuration file is updated with the new number of cores. \\
    \end{tabular}
    \caption{Use Case UC-03}\label{tab:uc-03}
\end{table}


\begin{table}[H]
    \centering
    \begin{tabular}{l p{10cm}}
        \toprule
        \multicolumn{2}{c}{\textbf{ID:\@ UC-04}} \\
        \toprule
        \textbf{Name}               &  Select Programming Language \\
        \textbf{Actors}             &  User \\
        \textbf{Objective}          &  Choose the programming language (Python, C++, or Go) for the ray-tracer execution. \\
        \textbf{Description}        & \textsl{1.} The user reviews the available implementations. \\
                                   & \textsl{2.} The user selects the desired programming language (Python, C++, or Go). \\
                                   & \textsl{3.} The user ensures the required dependencies for the selected language are installed. \\
                                   & \textsl{4.} The user proceeds to execute the benchmark or rendering task using the chosen implementation. \\
        \textbf{Preconditions}      &  All language implementations are available and properly installed. \\
        \textbf{Postconditions}     &  The selected language implementation is used for subsequent operations. \\
    \end{tabular}
    \caption{Use Case UC-04}\label{tab:uc-04}
\end{table}


\section{Traceability}

This section provides a traceability matrix that maps the requirements to the use cases. The matrix is designed to ensure that all requirements are addressed by the use cases defined in this document. \autoref{tab:func-traceability-matrix} shows the functional requirements, while \autoref{tab:non-func-traceability-matrix} shows the non-functional requirements, both with their corresponding use cases.



\begin{table}[]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Requirement} & \textbf{UC-01} & \textbf{UC-02} & \textbf{UC-03} & \textbf{UC-04} \\
        \hline
        RF-01                &                &                &                &                \\
        \hline
        RF-02                &  \checkmark    &                &                &                \\
        \hline
        RF-03                &                &                &  \checkmark    &                \\
        \hline
        RF-04                &                &                &  \checkmark    &                \\
        \hline
        RF-05                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RF-06                &  \checkmark    &                & \checkmark     &                \\
        \hline
        RF-07                & \checkmark     &  \checkmark    &                &                \\
        \hline
        RF-08                &  \checkmark    & \checkmark     &                &  \checkmark    \\         
        \hline
        RF-09                &                &                & \checkmark     &                \\
        \hline
        RF-10                &                &                &                &                \\
        \hline
        RF-11                & \checkmark     &                &                &                \\
        \hline
        RF-12                &                &                &                &  \checkmark    \\
        \hline  
        RF-13                &  \checkmark    &                &                &                \\
        \hline 
        RF-14                &  \checkmark    &                &                &                \\
        \hline
        RF-15                &  \checkmark    &                &                &                \\
        \hline
        RF-16                &  \checkmark    &                &                &                \\
        \hline
        RF-17                &  \checkmark    &                &                &  \checkmark     \\
        \hline
    \end{tabular}
\caption{Traceability matrix for functional requirement}\label{tab:func-traceability-matrix}
\end{table}



\begin{table}[]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Requirement} & \textbf{UC-01} & \textbf{UC-02} & \textbf{UC-03} & \textbf{UC-04} \\
        \hline
        RNF-01                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-02                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-03                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-04                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-05                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-06                & \checkmark     &                &  \checkmark    &                \\
        \hline
        RNF-07                & \checkmark     & \checkmark     &                &  \checkmark    \\       
        \hline
    \end{tabular}
\caption{Traceability matrix for functional requirement}\label{tab:non-func-traceability-matrix}
\end{table}


\begin{landscape}

\section{System Architecture}
\begin{tikzpicture}[
    auto,
    node distance=1.5cm and 2.5cm,
    block/.style={
    rectangle,
    draw,
    fill=blue!20,
    text width=8em,
    text centered,
    rounded corners,
    minimum height=3em,
    drop shadow
    },
    io/.style={
    trapezium,
    trapezium left angle=70,
    trapezium right angle=110,
    draw,
    fill=gray!20,
    text width=7em,
    text centered,
    minimum height=3em,
    drop shadow
    },
    class/.style={
    rectangle,
    draw,
    fill=green!20,
    text width=7em,
    text centered,
    rounded corners,
    minimum height=3em,
    drop shadow
    },
    baseclass/.style={
    class,
    fill=green!40,
    font=\bfseries
    },
    datastruct/.style={
    rectangle,
    draw,
    fill=orange!20,
    text width=6em,
    text centered,
    rounded corners,
    minimum height=2.5em,
    drop shadow
    },
    line/.style={-latex, thick}
    ]
% Nodes - Repositioned for better spacing
\node[block, text width=10em] (main) {program entrypoint (main)};
\node[io, above=1cm of main] (makefile) {Makefile};
\node[io, left=2.5cm of main] (scene_data) {sphere\_data.txt};

% Core classes - better spacing
\node[class, below left=2cm and 1cm of main] (camera) {camera};
\node[class, below right=2cm and 0cm of main] (hittable_list) {hittable\_list (world)};
\node[baseclass, right=3cm of hittable_list] (hittable) {hittable objects};

% Material hierarchy - moved down and spread out
\node[class, below=2.5cm of hittable] (sphere) {sphere};
\node[baseclass, left=3.5cm of sphere] (material) {material};

% Data structures - repositioned to avoid conflicts
\node[class, below=2.5cm of camera] (image) {Image};
\node[datastruct, below right=0.75cm and 2cm of camera] (vec3) {vec3 / color / point3};

\node[io, below=1cm of image] (output_ppm) {output.ppm};


% Arrows - rerouted to avoid overlaps
\draw[line] (makefile) -- node[midway, right] {builds \& runs} (main);
\draw[line] (scene_data) -- node[midway, above] {reads scene} (main);

% Main to components - using better angles
\draw[line] (main) -- node[midway, left] {configures} (camera);
\draw[line] (main) -- node[midway, right] {populates} (hittable_list);

% Camera connections - routed around components
\draw[line] (camera) -- node[midway, left] {writes pixels} (image);
\draw[line] (image) .. controls +(south:2) and +(north:2) .. node[midway, left] {writes file} (output_ppm);

% World interaction - curved to avoid conflicts
\draw[line] (camera) .. controls +(east:1.5) and +(west:1.5) .. node[midway, above] {world.hit()} (hittable_list);

% Inheritance relationships
\draw[line] (hittable_list) -- node[midway, above] {contains} (hittable);
\draw[line,dashed] (sphere) -- node[midway, right] {inherits} (hittable);
\draw[line] (sphere) .. controls +(west:2) and +(east:2) .. node[midway, above] {has a} (material);


% Data structure connections - routed to avoid overlaps
\draw[line] (camera) -- (vec3);
\draw[line] (sphere) -- (vec3);
\end{tikzpicture}

\end{landscape}

%% TODO: add a description for the system architecture and its components.