\chapter{Introduction}\label{chap:introduction}

\definecolor{otherrenew}{RGB}{120,150,100}
\definecolor{biofuels}{RGB}{150,120,90}
\definecolor{solar}{RGB}{220,150,120}
\definecolor{wind}{RGB}{60,80,120}
\definecolor{hydro}{RGB}{100,140,200}
\definecolor{nuclear}{RGB}{80,120,120}
\definecolor{natgas}{RGB}{120,100,150}
\definecolor{oil}{RGB}{180,120,120}
\definecolor{coal}{RGB}{120,80,80}
\definecolor{biomass}{RGB}{160,140,100}


\section{Motivation}\label{sec:motivation}
Energy consumption in the software industry has been rising over the years to the point where it is now significant at a global scale of energy consumption. % `Insert reference to papers that states how much energy software produces, not in embedded but in laptops, renderer (not washingmachines)`

As \cite{recalibrating-datacenter} states, in 2018 an estimated $1\%$ of total energy consumption was attributed to datacenters alone. In 2024, it is estimated that about $1.5\%$ of the world's energy consumption is to be blamed on data centers and server farms. Although these numbers may seem small, only $23,746$ TWh (12.96\%) of the total $183,230$ TWh produced in 2023 \cite{energy-production-consumption} came from renewable sources.

Selecting the appropriate programming language is critical, not only based on developer expertise but also on performance and efficiency considerations. If the goal of the program is a high-performance stock trader you would never think about using a high level language such as Python or Perl, but rather stick to compiled languages like C, C++ or Rust. 

The main motivation for this project lies in studying three different programming languages, each with its own peculiar characteristics, to test their respective speed and power consumption across different platforms and architectures

This comes from the idea that the program's efficiency does not come from the language itself, but the implementation of the algorithm that the programmer chooses. The language helps, but choosing the optimal algorithm is much more important.

My personal take in this project comes from my hesitation in choosing what programming language to use in many projects, their benefits and drawbacks, and the fact that I have been using many of these languages in multiple courses along these 4 years has made me realize the importance of choosing the correct language for each problem. 


\begin{figure}
    \centering
    \begin{tabular}{>{\raggedright}p{5cm}r}
        \multicolumn{2}{l}{\textbf{\Large 2023}} \\
        \multicolumn{2}{l}{in terawatt-hours} \\[0.5em]
        \toprule
            \textcolor{otherrenew}{\rule{0.4cm}{0.4cm}} Other renewables & 2,428 TWh \\
            \textcolor{biofuels}{\rule{0.4cm}{0.4cm}} Modern biofuels & 1,318 TWh \\
            \textcolor{solar}{\rule{0.4cm}{0.4cm}} Solar & 4,264 TWh \\
            \textcolor{wind}{\rule{0.4cm}{0.4cm}} Wind & 6,040 TWh \\
            \textcolor{hydro}{\rule{0.4cm}{0.4cm}} Hydropower & 11,014 TWh \\
            \textcolor{nuclear}{\rule{0.4cm}{0.4cm}} Nuclear & 6,824 TWh \\
            \textcolor{natgas}{\rule{0.4cm}{0.4cm}} Natural gas & 40,102 TWh \\
            \textcolor{oil}{\rule{0.4cm}{0.4cm}} Oil & 54,564 TWh \\
            \textcolor{coal}{\rule{0.4cm}{0.4cm}} Coal & 45,565 TWh \\
            \textcolor{biomass}{\rule{0.4cm}{0.4cm}} Traditional biomass & 11,111 TWh \\
        \midrule
        \textbf{Total} & \textbf{183,230 TWh} \\
        \bottomrule
    \end{tabular}
    \caption{Global electricity consumption by source that produced it in 2023, source: \cite{energy-production-consumption}}
    \label{fig:electricity_2023}
\end{figure}


\section{Goals}

The main goal of this project is the study and analysis of three implementations of a ray-tracer program, measuring the energy consumption as well as the time each program takes to complete. It should be also noted that the platform in which the program is being run affects the energy consumption of the program. 

To perform this, I have improved the code from a well-known book called Ray Tracing in One Weekend
\cite{Shirley2016RTW1}, translating it to  GO and Python, updating the code to handle parallel rendering. 

Once the code is created, the methodology for testing the different codes need to also be created. \begin{itemize}
    \item x86 Intel Xeon Based (2x Intel Xeon Gold 6326)
    \item x86 Zen 2 (AMD Ryzen 7 3800x)
    \item ARM Apple Icestorm \& Firestorm (M4 Pro 12 Core)
    \item ARM Cortex-A76 CPU - Raspberry Pi 5
\end{itemize} 

\section{Document Structure}\label{sec:structure}
The document contains the following chapters:
\begin{itemize}
  \item \chapterref{introduction}, details the motivation of the project.
  \item \chapterref{state-of-the-art}, describes the main points of interest in order to fully understand the project. Theoretical and technological issues are addressed.
  \item \chapterref{analysis}, states the project's goals, objectives and requirements.
  \item \chapterref{design}, describes the most relevant design decisions with the multi-language renderers and their multithreaded implementation.
  \item \chapterref{evaluation}, analyzes and discusses the benchmarks results and energy measurements.
  \item \chapterref{planning}, describes the organization of the project along the development.
  \item \chapterref{economic-env}, provides a comprehensive account of the project's developmental costs and its associated socio-economic implications.
  \item \chapterref{regulation}, indicates the licenses under which the project is distributed.
  \item \chapterref{conclusions}, briefly analyzes the results obtained and states the possible future objectives of the project.
\end{itemize}
