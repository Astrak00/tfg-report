\chapter{Introduction}\label{chap:introduction}

\definecolor{otherrenew}{RGB}{120,150,100}
\definecolor{biofuels}{RGB}{150,120,90}
\definecolor{solar}{RGB}{220,150,120}
\definecolor{wind}{RGB}{60,80,120}
\definecolor{hydro}{RGB}{100,140,200}
\definecolor{nuclear}{RGB}{80,120,120}
\definecolor{natgas}{RGB}{120,100,150}
\definecolor{oil}{RGB}{180,120,120}
\definecolor{coal}{RGB}{120,80,80}
\definecolor{biomass}{RGB}{160,140,100}


\section{Motivation}\label{sec:motivation}
Energy consumption in the software industry has risen to become globally significant. % `Insert reference to papers that states how much energy software produces, not in embedded but in laptops, renderer (not washingmachines)`

As \cite{recalibrating-datacenter} states, in 2018 an estimated $1\%$ of total energy consumption was attributed to data centers alone. In 2024, it is estimated that about $1.5\%$ of the world's energy consumption is due to data centers and server farms. Although these numbers may seem small, only $23.746$ TWh (12.96\%) came from renewable sources of the total $183.230$ TWh produced in 2023 \cite{energy-production-consumption}.


The main motivation for this project lies in studying three different programming languages, each with distinctive characteristics, to test their respective speed and power consumption across different platforms and architectures.

My personal motivation for this project stems from my hesitation in choosing which programming language to use in many projects. Their benefits and drawbacks, and the fact that I have been using many of these languages in multiple courses over the past four years have made me realize the importance of choosing the correct language for each problem.

Selecting the appropriate programming language is critical, not only based on developer expertise but also on performance and efficiency considerations. For example, if the goal is a high-performance stock trading system, you would not use a high-level language such as Python or Perl, but rather stick to compiled languages like C, C++ or Rust.

This comes from the idea that the program's efficiency does not come only from the implementation of the algorithm but by the algorithm itself. The language helps, but choosing the optimal algorithm is much more important.



\begin{figure}
    \centering
    \begin{tabular}{>{\raggedright}p{5cm}r}
        \multicolumn{2}{l}{\textbf{\Large 2023}} \\
        \multicolumn{2}{l}{in terawatt-hours} \\[0.5em]
        \toprule
            \textcolor{otherrenew}{\rule{0.4cm}{0.4cm}} Other renewables & 2,428 TWh \\
            \textcolor{biofuels}{\rule{0.4cm}{0.4cm}} Modern biofuels & 1,318 TWh \\
            \textcolor{solar}{\rule{0.4cm}{0.4cm}} Solar & 4,264 TWh \\
            \textcolor{wind}{\rule{0.4cm}{0.4cm}} Wind & 6,040 TWh \\
            \textcolor{hydro}{\rule{0.4cm}{0.4cm}} Hydropower & 11,014 TWh \\
            \textcolor{nuclear}{\rule{0.4cm}{0.4cm}} Nuclear & 6,824 TWh \\
            \textcolor{natgas}{\rule{0.4cm}{0.4cm}} Natural gas & 40,102 TWh \\
            \textcolor{oil}{\rule{0.4cm}{0.4cm}} Oil & 54,564 TWh \\
            \textcolor{coal}{\rule{0.4cm}{0.4cm}} Coal & 45,565 TWh \\
            \textcolor{biomass}{\rule{0.4cm}{0.4cm}} Traditional biomass & 11,111 TWh \\
        \midrule
        \textbf{Total} & \textbf{183,230 TWh} \\
        \bottomrule
    \end{tabular}
    \caption{Global electricity consumption by source that produced it in 2023, source: \cite{energy-production-consumption}}
    \label{fig:electricity_2023}
\end{figure}


\section{Goals}

The main goal of this project is the study and analysis of three implementations of a ray-tracer program, measuring the energy consumption as well as the time each program takes to finalize. It should be also noted that the platform in which the program is being run affects the energy consumption of the program significantly.

\begin{enumerate}
    \item \textbf{Goal 1}: Optimize the C++ implementation of the ray-tracer and add a multithreaded implementation.
    \item \textbf{Goal 2}: Create a Go and Python implementations of the ray-tracer with both single-threaded and multithreaded versions.
    \item \textbf{Goal 3}: Create a benchmarking suite to measure the time and energy consumption of each implementation on these platforms:
    \begin{itemize}
        \item x86 Intel Xeon Based (2x Intel Xeon Gold 6326)
        \item x86 Zen 2 (AMD Ryzen 7 3800x)
        \item ARM Apple Icestorm \& Firestorm (M4 Pro 12 Core)
        \item ARM Cortex-A76 CPU - Raspberry Pi 5
    \end{itemize}   
    \item \textbf{Goal 4}: Analyze the results and draw conclusions on the performance and energy consumption of each implementation on each platform.
\end{enumerate}

To perform these goals, I have improved the C++ code from a well-known book called Ray Tracing in One Weekend
\cite{Shirley2016RTW1}, translating it to Go and Python, and updating the code to handle parallel rendering. 


\label{list:platforms}

\section{Document Structure}\label{sec:structure}
The document contains the following chapters:
\begin{itemize}
  \item \chapterref{introduction}, details the motivation of the project.
  \item \chapterref{state-of-the-art}, describes the main points of interest in order to fully understand the project. Theoretical and technological issues are addressed.
  \item \chapterref{analysis}, states the project's goals, objectives and requirements.
  \item \chapterref{design}, describes the most relevant design decisions with the multi-language renderers and their multithreaded implementation.
  \item \chapterref{evaluation}, analyzes and discusses the benchmarks results and energy measurements.
  \item \chapterref{planning}, describes the organization of the project throughout its development.
  \item \chapterref{economic-env}, provides a comprehensive account of the project's developmental costs and associated socioeconomic implications.
  \item \chapterref{regulation}, indicates the licenses under which the project is distributed.
  \item \chapterref{conclusions}, summarizes the results and outlines possible future objectives.
\end{itemize}
