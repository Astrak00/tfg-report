\chapter{Conclusions}\label{chap:conclusions}


\section{Summary of Findings}
After analyzing the data collected from the various experiments, we found that the most efficient programming language, by a great margin is \gls{CPP}. The results indicate that \gls{CPP} outperforms both in energy consumption and execution time when compared to \gls{CPython}, Go and PyPy. This was to be expected, as \gls{CPP} is a compiled language and is known for its performance and energy efficiency, as it is an evolution of C.

The most impressive and surprising result for many tests has been the performance of PyPy compared to the other programming languages. PyPy is just an interpreter for Python (that can run a limited subset of what \gls{CPython} can run), but it uses a \gls{jit} compilation technique that allows it to execute Python code much faster than the standard interpreter. This \gls{jit} is not compatible with some python libraries such as Numpy \cite{numpy} as these libraries use \gls{c-extension} to speed up their execution. This means that PyPy can only be used with pure Python code, which limits its applicability in some cases.

The implementation of multiple threads in the different programming languages was also a key factor in the performance of the programs. The easiest to implement, and the one that showed the best results, was C++, followed by Go, with its \glspl{goroutine} and \glspl{channel}. 

Python's default implementation, \gls{CPython}, does not support true multithreading due to the \gls{GIL}, which limits the performance of multi-threaded programs, thus, the need of the library multithreading is needed.

If we were to use libraries such as \Gls{numpy}, the performance of \gls{CPython} would be much better, as these libraries are optimized for performance and can take advantage of the underlying hardware. However, this would not be a fair comparison, as we would not be using pure Python code.

If I was to deploy a render-farm, with this program, I could be paying 10x less energy costs if I used \gls{CPP} instead of \gls{CPython} or Go, and renders could take up to 2x less time. This is a significant difference, and it is clear that \gls{CPP} is the best choice for this type of application.

There is an interesting outlier in this analysis, which are the results of pypy on the laptop. Specifically, if we look at the results of the relative energy efficiency (\autoref{fig:laptop-relative-energy}), we can see that PyPy, as the number of cores increase, the relative energy efficiency decreases, while the other programming languages increase. This seems to indicate that PyPy is not able to take advantage of the multiple cores in the laptop as well as other platforms. I have some possible ideas on why this might happen; My first hypothesis was that the implementation being used on the laptop was an emulation of the x86 version of PyPy using Rosetta 2 (\cite{apple:rosetta2}), but when checking the `Activity Monitor', it is clear that this process is native to ARM.\@ My second hypothesis is that this is due to the fact that, as this is one of the platforms that does not use x86 architecture, the \gls{jit} compilation is not as effective.

In conclusion, if the program is to be run only a couple of times, and the performance is not a key factor, \gls{CPython} is a good enough choice. However, if the program is to be run multiple times, or if performance is a key factor, \gls{CPP} is the best choice. Go is also a good choice, as it has a good balance between performance and ease of use, specially for hundreds of threads working light tasks, for example a web server. PyPy is a good choice for pure Python code, but it has limitations when it comes to libraries that use \glspl{c-extension}.

This comes as an interesting conclusion, as when I think about a program or funciton that has to be run multiple times, I think about a web serverless function, for example AWS Lambda (\cite{aws:lambda}), but in the \href{https://docs.aws.amazon.com/lambda/latest/dg/lambda-samples.html}{examples} they provide, there is no mention either of PyPy or C++. The main focus they have is Node.js (a JavaScript runtime), Python, Ruby, Java, and, in the fifth place, Go. This is an interesting choice, as it seems that the focus is on ease of use rather than performance. I think this is also due to the fact that these services charge by execution time, so the slower the execution time, the more they can charge the costumer. 

\section{Future Research}
Future research could focus on the following areas:
\begin{itemize}
    \item Investigating the performance of other programming languages, such as Rust, Javascript, or Java, in similar scenarios.
    \item Exploring the impact of different libraries and frameworks on the performance of the programming languages.
    \item Analyzing the performance external accelerators such as \gls{gpu} or \gls{fpga} in conjunction with the programming languages.
    \item Conducting a more extensive analysis of the performance of the programming languages in different scenarios, such as web applications, data processing, or machine learning.
    \item Analyzing more workloads, such a web-server or a database, to see how the programming languages perform in these scenarios.
    \item Investigating the impact of different hardware configurations on the performance of the programming languages such as the \gls{ram} speed, size and SSD storage speed.
    \item Exploring the impact of different operating systems on the performance of the programming languages, such as Linux, Windows, or macOS.
\end{itemize}