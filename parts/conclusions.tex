\chapter{Conclusions}\label{chap:conclusions}

After analyzing the data collected from the various experiments, I clearly confirmed the election of a programming language does affect the performance and energy consumption. 

I found that the most efficient programming language, by a great margin is \gls{CPP}, outperforming in every case. The results indicate that it outperforms both in energy consumption and execution time when compared to Go, a compiled language, and interpretations of languages, such as \gls{CPython} or PyPy, the other languages and implementations of languages used in this project. This was to be expected, as \gls{CPP} is a compiled language and is known for its performance and energy efficiency, as it is an evolution of C.

The program used to perform the benchmarks is an image renderer, that processes each pixel of an image, casting multiple rays per pixel, and calculating the color of each one based on the intersection of the rays with the objects in the scene. This is a computationally intensive task that uses the \gls{ALU}, that can be parallelized.

This benchmark has been performed on the same component, the \gls{cpu}, even when performing the benchmarks on different platforms, such as a desktop computer, a laptop, and a \gls{SBC}.

\section{Summary of Findings}

The main findings of this project are that \gls{CPP} is up to $440$ times faster and $300$ times more energy efficient on the Server than \gls{CPython}, and up to $180$ times faster and $150$ times more energy efficient on the Raspberry Pi (the two extremes of the platforms used in this project). 

On every test case, \gls{CPP} outperformed the other programming languages, given the same number of cores and platform. An interesting result is that the lowerst consuming board has been the Raspberry Pi, due to its design for IoT low-consumption devices. For each of the languages tested, the performance on up to 4 cores on each platform is detailed on this graph:

\input{parts/conclusions/grouped_graphs.tex}

\section{Discussion of Results}

% Move this to a different section
The most impressive and surprising result for many tests has been the performance of PyPy compared to the other programming languages. PyPy is just an interpreter for Python (that can run a limited subset of what \gls{CPython} can run), but it uses a \gls{jit} compilation technique that allows it to execute Python code much faster than the standard interpreter. This \gls{jit} is not compatible with some python libraries such as Numpy \cite{numpy} as these libraries use \gls{c-extension} to speed up \gls{CPython}'s speed. This means that PyPy can only be used with pure Python code, which limits its applicability in some cases.

The implementation of multiple threads in the different programming languages was also a key factor in the performance of the programs. Depending on the technique used, parallelizing for each line or for each pixel, the performance deferred on the different languages. The easiest to implement, and the one that showed the best results, was C++, followed by Go, with its \glspl{goroutine} and \glspl{channel}. Python's default implementation, \gls{CPython}, does not support true multithreading due to the \gls{GIL}, which limits the performance of multi-threaded programs, thus, the need of the library multithreading is needed.

If we were to use libraries such as \Gls{numpy}, the performance of \gls{CPython} would be much better, as these libraries are optimized for performance and can take advantage of the underlying hardware. However, this would not be a fair comparison, as we would not be using pure Python code.

If I was to deploy a render-farm, with this program, I could be paying 300x less energy costs if I used \gls{CPP} instead of \gls{CPython} or Go, and renders could take up to 400x less time. This is a significant difference, and it is clear that \gls{CPP} is the best choice for these types of application.

There is an interesting outlier in this analysis, which are the results of pypy on the laptop. Specifically, if we look at the results of the relative energy efficiency (\autoref{fig:laptop-relative-energy}), we can see that PyPy, as the number of cores increase, the relative energy efficiency decreases, while the other programming languages increase. This seems to indicate that PyPy is not able to take advantage of the multiple cores in the laptop as well as other platforms. I have some possible ideas on why this might happen; My first hypothesis was that the implementation being used on the laptop was an emulation of the x86 version of PyPy using Rosetta 2 (\cite{apple:rosetta2}), but when checking the `Activity Monitor', it is clear that this process is native to ARM.\@ My second hypothesis is that this is due to the fact that, as this is one of the platforms that does not use x86 architecture, the \gls{jit} compilation is not as effective.

In conclusion, if the program is to be run only a couple of times, and the performance is not a key factor, \gls{CPython} is a good enough choice. However, if the program is to be run multiple times, or if performance is a key factor, \gls{CPP} is the best choice. Go is also a good choice, as it has a good balance between performance and ease of use, specially for hundreds of threads working light tasks, for example a web server. PyPy is a good choice for pure Python code, but it has limitations when it comes to libraries that use \glspl{c-extension}.

This comes as an interesting conclusion, as when I think about a program or funciton that has to be run multiple times, I think about a web serverless function, for example AWS Lambda (\cite{aws:lambda}), but in the \href{https://docs.aws.amazon.com/lambda/latest/dg/lambda-samples.html}{examples} they provide, there is no mention either of PyPy or C++. The main focus they have is Node.js (a JavaScript runtime), Python, Ruby, Java, and, in the fifth place, Go. This is an interesting choice, as it seems that the focus is on ease of use rather than performance. I think this is also due to the fact that these services charge by execution time, so the slower the execution time, the more they can charge the costumer. 


\section{Future Research}
Future research could focus on the following areas:
\begin{itemize}
    \item Investigating the performance of other programming languages, such as Rust, Javascript, or Java, in similar scenarios.
    \item Exploring the impact of different libraries and frameworks on the performance of the programming languages.
    \item Analyzing the performance external accelerators such as \gls{gpu} or \gls{fpga} in conjunction with the programming languages.
    \item Conducting a more extensive analysis of the performance of the programming languages in different scenarios, such as web applications, data processing, or machine learning.
    \item Analyzing more workloads, such a web-server or a database, to see how the programming languages perform in these scenarios.
    \item Investigating the impact of different hardware configurations on the performance of the programming languages such as the \gls{ram} speed, size and SSD storage speed.
    \item Exploring the impact of different operating systems on the performance of the programming languages, such as Linux, Windows, or macOS.
\end{itemize}